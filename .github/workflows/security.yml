name: üîí Security Scanning

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  schedule:
    # Run security scans daily at 2 AM UTC
    - cron: "0 2 * * *"
  workflow_dispatch:

env:
  GO_VERSION: "1.23"

jobs:
  # Job 1: Static Application Security Testing (SAST)
  sast:
    name: üîç Static Security Analysis
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      actions: read
      contents: read
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üêπ Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: üì¶ Download dependencies
        run: |
          go mod download
          go work sync

      - name: üîí Run gosec security scanner
        uses: securego/gosec@master
        with:
          args: "-fmt sarif -out gosec.sarif -exclude-dir=tests ./..."
        continue-on-error: true

      - name: üìä Upload gosec SARIF file
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: gosec.sarif
        continue-on-error: true

      - name: üîç Run Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/secrets
            p/golang
            p/docker
            p/kubernetes
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
        continue-on-error: true

  # Job 2: Dependency Vulnerability Scanning
  dependency-scan:
    name: üì¶ Dependency Security Scan
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      actions: read
      contents: read
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üêπ Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: üì¶ Download dependencies
        run: |
          go mod download
          cd shared && go mod download

      - name: üîç Run govulncheck vulnerability scanner
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          govulncheck ./...

      - name: üîç Run Snyk to check for vulnerabilities
        uses: snyk/actions/golang@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=medium --sarif-file-output=snyk.sarif
        continue-on-error: true

      - name: üìä Upload Snyk SARIF file
        uses: github/codeql-action/upload-sarif@v3
        if: always() && hashFiles('snyk.sarif') != ''
        with:
          sarif_file: snyk.sarif

      - name: üîç Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"

      - name: üìä Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: "trivy-results.sarif"

  # Job 3: Container Security Scanning
  container-scan:
    name: üê≥ Container Security Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      actions: read
    strategy:
      matrix:
        service: [calculator, tracker, wallet, user-auth]
      fail-fast: false
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîç Check if Dockerfile exists
        id: dockerfile-check
        run: |
          if [ -f "./services/${{ matrix.service }}/Dockerfile" ]; then
            echo "dockerfile-exists=true" >> $GITHUB_OUTPUT
          else
            echo "dockerfile-exists=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Dockerfile not found for ${{ matrix.service }}, skipping container scan"
          fi

      - name: üî® Build Docker image
        if: steps.dockerfile-check.outputs.dockerfile-exists == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./services/${{ matrix.service }}/Dockerfile
          tags: security-scan:${{ matrix.service }}
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: üîç Run Trivy container scan
        if: steps.dockerfile-check.outputs.dockerfile-exists == 'true'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: "security-scan:${{ matrix.service }}"
          format: "sarif"
          output: "trivy-container-${{ matrix.service }}.sarif"

      - name: üìä Upload Trivy container scan results
        if: steps.dockerfile-check.outputs.dockerfile-exists == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: "trivy-container-${{ matrix.service }}.sarif"
        continue-on-error: true

      - name: üîç Run Grype vulnerability scanner
        if: steps.dockerfile-check.outputs.dockerfile-exists == 'true'
        uses: anchore/scan-action@v3
        with:
          image: "security-scan:${{ matrix.service }}"
          fail-build: false
          severity-cutoff: high
        continue-on-error: true

      - name: üîç Run Docker Scout
        if: steps.dockerfile-check.outputs.dockerfile-exists == 'true'
        uses: docker/scout-action@v1
        with:
          command: cves
          image: "security-scan:${{ matrix.service }}"
          sarif-file: "scout-${{ matrix.service }}.sarif"
          summary: true
        continue-on-error: true

      - name: üìä Upload Docker Scout scan results
        if: steps.dockerfile-check.outputs.dockerfile-exists == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: "scout-${{ matrix.service }}.sarif"
        continue-on-error: true

  # Job 4: Infrastructure as Code Security
  iac-scan:
    name: üèóÔ∏è Infrastructure Security Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      actions: read
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîç Run Checkov
        uses: bridgecrewio/checkov-action@master
        with:
          directory: .
          framework: dockerfile,kubernetes
          output_format: sarif
          output_file_path: checkov.sarif
          soft_fail: true
        continue-on-error: true

      - name: üìä Upload Checkov scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: checkov.sarif
        continue-on-error: true

      - name: üîç Run Terrascan
        uses: tenable/terrascan-action@main
        with:
          iac_type: "docker"
          iac_version: "v1"
          policy_type: "docker"
          only_warn: true
          sarif_upload: true
        continue-on-error: true

      - name: üîç Scan Kubernetes manifests with Kubesec
        run: |
          if [ -d "k8s" ]; then
            docker run --rm -v $(pwd):/workspace kubesec/kubesec:latest scan /workspace/k8s/*.yaml
          fi
        continue-on-error: true

  # Job 5: Secrets Scanning
  secrets-scan:
    name: üîê Secrets Detection
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîç Run TruffleHog
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.repository.default_branch }}
          head: ${{ github.sha }}
          extra_args: --debug --only-verified
        continue-on-error: true

      - name: üîç Run GitLeaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üîç Run detect-secrets
        run: |
          pip install detect-secrets
          # Create baseline if it doesn't exist
          if [ ! -f .secrets.baseline ]; then
            detect-secrets scan --all-files > .secrets.baseline
          fi
          detect-secrets scan --all-files --baseline .secrets.baseline

  # Job 6: License Compliance
  license-scan:
    name: üìÑ License Compliance
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üêπ Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: üì¶ Install go-licenses
        run: go install github.com/google/go-licenses@latest

      - name: üîç Check licenses
        run: |
          go-licenses check ./...
          go-licenses csv ./... > licenses.csv

      - name: üìä Upload license report
        uses: actions/upload-artifact@v4
        with:
          name: license-report
          path: licenses.csv

  # Job 7: Security Policy Compliance
  policy-check:
    name: üìã Security Policy Check
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: ‚úÖ Check required security files
        run: |
          echo "Checking for required security files..."

          # Check for SECURITY.md
          if [ ! -f "SECURITY.md" ]; then
            echo "‚ùå SECURITY.md file is missing"
            exit 1
          else
            echo "‚úÖ SECURITY.md found"
          fi

          # Check for CODE_OF_CONDUCT.md
          if [ ! -f "CODE_OF_CONDUCT.md" ]; then
            echo "‚ö†Ô∏è CODE_OF_CONDUCT.md file is missing"
          else
            echo "‚úÖ CODE_OF_CONDUCT.md found"
          fi

          # Check for LICENSE
          if [ ! -f "LICENSE" ]; then
            echo "‚ùå LICENSE file is missing"
            exit 1
          else
            echo "‚úÖ LICENSE found"
          fi

      - name: üîç Check Dockerfile security best practices
        run: |
          echo "Checking Dockerfile security practices..."

          for dockerfile in $(find . -name "Dockerfile"); do
            echo "Checking $dockerfile..."

            # Check for non-root user
            if ! grep -q "USER" "$dockerfile"; then
              echo "‚ö†Ô∏è $dockerfile: Consider adding non-root USER instruction"
            fi

            # Check for HEALTHCHECK
            if ! grep -q "HEALTHCHECK" "$dockerfile"; then
              echo "‚ö†Ô∏è $dockerfile: Consider adding HEALTHCHECK instruction"
            fi

            # Check for specific versions in FROM
            if grep -q "FROM.*:latest" "$dockerfile"; then
              echo "‚ö†Ô∏è $dockerfile: Avoid using :latest tag in FROM instruction"
            fi
          done

      - name: üîç Check for hardcoded secrets patterns
        run: |
          echo "Checking for potential hardcoded secrets..."

          # Common secret patterns
          if grep -r -i "password.*=" --include="*.go" --include="*.yaml" --include="*.yml" .; then
            echo "‚ö†Ô∏è Found potential hardcoded passwords"
          fi

          if grep -r -i "api[_-]key" --include="*.go" --include="*.yaml" --include="*.yml" .; then
            echo "‚ö†Ô∏è Found potential hardcoded API keys"
          fi

          if grep -r -i "secret.*=" --include="*.go" --include="*.yaml" --include="*.yml" .; then
            echo "‚ö†Ô∏è Found potential hardcoded secrets"
          fi

  # Job 8: Generate Security Report
  security-report:
    name: üìä Generate Security Report
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
    needs:
      [
        sast,
        dependency-scan,
        container-scan,
        iac-scan,
        secrets-scan,
        license-scan,
        policy-check,
      ]
    if: always()
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üìä Generate security summary
        run: |
          echo "# üîí Security Scan Summary" > security-report.md
          echo "" >> security-report.md
          echo "**Scan Date:** $(date -u)" >> security-report.md
          echo "**Repository:** ${{ github.repository }}" >> security-report.md
          echo "**Branch:** ${{ github.ref_name }}" >> security-report.md
          echo "**Commit:** ${{ github.sha }}" >> security-report.md
          echo "" >> security-report.md

          echo "## üìã Scan Results" >> security-report.md
          echo "" >> security-report.md
          echo "| Scan Type | Status |" >> security-report.md
          echo "|-----------|--------|" >> security-report.md
          echo "| Static Analysis (SAST) | ${{ needs.sast.result }} |" >> security-report.md
          echo "| Dependency Scan | ${{ needs.dependency-scan.result }} |" >> security-report.md
          echo "| Container Scan | ${{ needs.container-scan.result }} |" >> security-report.md
          echo "| Infrastructure Scan | ${{ needs.iac-scan.result }} |" >> security-report.md
          echo "| Secrets Scan | ${{ needs.secrets-scan.result }} |" >> security-report.md
          echo "| License Compliance | ${{ needs.license-scan.result }} |" >> security-report.md
          echo "| Policy Check | ${{ needs.policy-check.result }} |" >> security-report.md
          echo "" >> security-report.md

          echo "## üîó Links" >> security-report.md
          echo "" >> security-report.md
          echo "- [Security Policy](SECURITY.md)" >> security-report.md
          echo "- [GitHub Security Advisories](https://github.com/${{ github.repository }}/security/advisories)" >> security-report.md
          echo "- [Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> security-report.md

      - name: üìä Upload security report
        uses: actions/upload-artifact@v4
        with:
          name: security-report
          path: security-report.md

      - name: üí¨ Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('security-report.md', 'utf8');

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: report
            });
